#pragma once
/*
* ---------------------
1기초자료구조: 선형외나머지
	1자료구조란
	2스택과 큐
	3트리
	4우선순위 큐와 힙
2핵심알고리즘유형
	1재귀호출
	2알고리즘개발순서
	3분할정복법
	4탐욕적기법
3알고리즘심화
	1동적계획법기초
	2동적계획법심화
	3그래프알고리즘기초
	4그래프알고리즘심화

#자료구조
추상자료형 : 구현이 없는 개념 => 코드상에서는 '인터페이스'란 이름으로 존재(부모클래스의 또다른이름) (vs 자료구조 => 자식 클래스)
	: 객체지향구조에서 추상메서드로만 이루어진 설계용 클래스, 구현이 없는 정의만 있는 상속용 클래스
	: '리스트'라는 인터페이스에서는 "삽입과 삭제를 조회를 지원해야한다"라는 명세만 주어지고 실제 동작은 상속받은 자식 클래스에서 구현

1배열 		장:읽기빠름	단:쓰기삭제느림(운좋으면빠름)	n(n+1)/2 → O(n^2) : 밀어줘야하는 경우 생김
2연결리스트	단:읽기느림	장:쓰기삭제빠름 				n  	 → O(n)

해쉬테이블(딕셔너리) : 배열의 한종류, 인덱스대신 hashing한 값을 씀
	장 : 메모리미리안잡아둬도됨,비어있는인덱스관리가능, 읽기느림 	단 : 인덱스의 장점인 순서 확인 기능이 없음, 쓰기느림 //대표적인 알고리즘SHA-256
	해쉬충돌존재 -> 해결방법 1.개별체이닝-해쉬값뒤에 연결리스트를 추가하여 관리 2.오픈어드레싱-다음빈공간탐색(선형탐사방식)..동일한 주소 보장x

*알고리즘* 계산을 통하여 문제를 해결하는 방법, 순서도=>의사코드(작동x)
	.유한성 : 종료되어야함
	.명확성 : 각 단계가 신뢰성있고 명확해야
	.입력/출력 : 입력은 0이상, 출력은 1이상
	.효과성 : 시공간적 효율성 + 실용적이어야함

	- 개발순서 : 
		.1문제이해 
		.2알고리즘개발(최초에 완전탐색법으로 고려해야함) 
		.<3중요>문제해결증명(실제값으로시뮬해보기) 
		.<4중요>시간복잡도확인 : Big-O시간복잡도에 실제 예상되는 코드계산시간 넣어서 가늠해보기
			..복잡도이론 : n^k다항복잡도(p클래스문제) < n! or 2^n(p클래스보다 훨씬오래걸림)
			..NPclass:비결정다항시간(Non-deterministic Polynomial time, 해결책은 찾기 어렵지만(다항시간초과) 검증은 빠름(다항시간) ex해밀턴경로문제
			..NP-Complete class:입력이 극도로 작을때만 풀수있음 ex외판원문제(실상최적회문제로분류),정점커버문제
		.5코드작성 
		.6로직디버깅하면안됨(오타는ok)


*자료구조*
* Why?
* Where?
* 
	- 선형구조

		-- 스택	: LIFO 구멍이 1개인 통, 시퀸스간 의존적관계가 있을때 or 우선순위있을때
			push
			pop
			top
			empty
			--- (추상)재귀함수(재귀적-계산법) : 계산의 return이 특정 값에 수렴하기 위해서는, 'n-1과 같은 식을 인자로하는 자신의 함수'를 계산에 포함하여 return해야 수렴해야할듯
				.수학적귀납법(재귀적-증명법) : 자연수n에 대해 명제f(x)를 증명한다면, n=1일때 증명(기저조건or베이스컨디션), k가 성립한다고 가정하고 k+1을 증명 => 모든 자연수 n에 대해 성립
					..하나의 명제를 재귀적으로 증명하는 방법 => 재귀적인 방법이란 하나의 명제를 증명하기위해서 그 증명에 똑같은 증명을 사용한다는 것 => 증명방법안에 자기증명이 사용된 것
			--- (추상)분할정복법(재귀함수의 확장) : 		
			--- (구현)팩토리얼 : ...4*3*2*1 exDFS탐색
			--- (구현)퀵정렬 : 일반정렬중가장빠름, 맨앞수를 pivot으로 두고 앞수부터 검사하여 작은수는 왼쪽에 배열, 큰수는 오른쪽에 배열 / 새로 생긴 2개의 배열에 대해 퀵정렬 재귀

		-- 큐	: FIFO 입구/출구, 구멍이 2개인 통, 병렬작업할때 or
			push	rear위치에 자료저장후 rear에 +1 
			pop
			front
			back
			empty
			--- (추상)원형큐	: 입구와 출구를 연결한 통 front-rear
			--- (구현)링크드큐 : 연결리스트로 구현한 큐 head-tail
			--- (추상)스케줄링 : 운영체제의 자원할당 ex시분할시스템
			--- (추상)우선순위큐 : 우선순위가 높은 원소가 먼저출력

	- 비선형구조

		-- 트리 : 그래프중 하나, 정점(vertex or node)와 간선(edge)로 이루어진 자료구조
			.유향그래프(간선의 진행에 방향이 있음)
			.정점의 부모 노드는 1개, 0개라면 루트 노드, 루트까지의 거리는 깊이
			.정점간 간선은 1개(중복경로없음)
			.사이클불가
			--- (추상)이진트리 : 자식노드 최대 2개, 편향이진트리는 지양해야
			--- (추상)정이진트리 : 리프노드를 제외한 모든노드는 자식노드 2개
			--- (추상)완전이진트리 : 마지막 깊이 제외 모든 정점 존재, 마지막 깊이의 정점은 가능한 왼쪽에 배치  => 배열구현가능 : n의 자식 2n,2n+1
			--- (구현)힙 : 부모자식간 대소관계+완전이진트리, 최소힙(부모<자식) / 최대힙(부모>자식) / 절대값힙 (절대값기준 최소힙)
				.출력은 루트, 맨마지막 원소를 루트로, 마지막원소가 최대값일때 O(logn)
				.입력은 맨아래오른쪽끝에, 입력이 최소값일때 O(logn)
				.단순배열대비장점은 시간복잡도, 배열(입출력 O1 On) 힙(입출력 Ologn Ologn) 힙정렬(입출력 Onlogn Onlogn)
			--- (추상)포화이진트리 : 항상 자식은 2개, 모든 리프 노드의 깊이 같음, 정점의 개수는 2^h-1
			--- (추상)자가균형이진탐색트리 : 레드블랙트리

		-- 그래프 : 자기자신(정점)으로 돌아오는 경로(사이클)가 존재가능
			.BFS너비우선탐색 : 부모를 공유하는 인접노드를 우선탐색, 이웃한 정점을 먼저 방문 => (큐): 팝을 재귀하는 식으로 다음차례 큐에 넣으면서 탐색, 팝한 순서대로 리턴~(선입선출)
				..자식/왼쪽우선
			.DFS깊이우선탐색 : 한분기 모두 탐색후 다음분기 탐색(기저까지 갔다가 올라오면서 기저갈 기회 탐색) => 재귀함수 (스택): 내려갈때는 스택에 쌓고 올라오면서 팝(후입선출)
				..전위순회(부모/왼쪽우선)	: 루트 => 왼쪽 서브트리순회 => 오른쪽 서브트리순회 preorder
				..중위순회(왼쪽/부모우선)	: 왼쪽 서브트리순회 => 루트 => 오른쪽 서브트리순회 inorder **많이씀** (+너비구하기)
				..후위순회(왼쪽/자식우선)	: 왼쪽 서브트리순회 => 오른쪽 서브트리순회 => 루트 postorder
			.무방향그래프 / 방향그래프 : 간선의 방향여부
			--- (추상)인접행렬 : 모든관계를 기록, 인접한 정점을 1-0행렬로 표현, 1-0대신 가중치 넣어도됨, 무방향그래프는 행렬이 11시방향으로 대칭을 이룸
			--- (추상)인접리스트 : 연결관계만 기록, 헤더의 연결정보를 배열에 순차저장(그외연관성x), 정점의 개수만큼을 인덱스로 가진 배열임(각 인덱스는 배열형태로 인자간 관계를 저장)
			--- (구현)최단거리 :
				.다익스트라
				.벨만포드 : 감소고려(음의가중치)
			--- (구현)최소신장트리 : 
				.크루스칼 = 최소비용 노드 무조건 우선연결
				.프림 = 트리 접근가능범위에서 최소비용 노드 우선연결

				





















*/