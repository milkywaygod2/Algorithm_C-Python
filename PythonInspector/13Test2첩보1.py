'''
전달할 암호는 n개
전달수단인 단말기에는 암호문자1개 입력되어있음

단말기의 기능은 아래3가지임
1.단말기의 모든 암호문자를 복사하여 버퍼에 저장
2.버퍼에 있는 암호문자를 단말기에 붙여넣기
3.단말기에 입력된 암호문자중 하나 제거

n개의 암호문자를 정확하게 보내기위한 최소시간은?

입력
첫째줄에 n이 입력된다.(5<=n<=500)
n : 엘리스가 전송해야 할 암호 문자의 개수

출력
send_message함수에서 n개의 문자를 정확히 보내기위한 최소시간을 반환.

입력예시1
2

출력예시1
2

출력예시1설명
복사->붙여넣기 동작으로 2초가 걸린다.

입력예시2
10

출력예시2
7

출력예시2설명
복사->붙여넣기->복사->붙여넣기->붙여넣기->붙여넣기->붙여넣기 동작으로 7초가 걸린다.

여기서 암호 전송의 의미는, 암구호 1개가 있고 그걸 몇번 반복하게 해야하냐 그게 입력이고
반복하게 하는 방법은, 지금까지 반복된 암구호를 버퍼에 넣고 붙여넣기로 그만큼 추가하거나 하나뺴기 두가지 방법있음.

[비유법]
처음에 바구니에 계란이 1개가 있어 

각 단계별로 아래 동작중 하나를 할 수 있고 각 1초가 걸려
copy.바구니에 있는 계란 개수만큼 변수에 저장한다.
paste.바구니에 변수에 저장된 개수만큼을 계란을 더해준다.
subtract.바구니에서 계란을 1개를 뺀다.

처음 1개에서 시작해서 바구니에 n개를 만들기위해, 몇 초가 걸리는지 구하는 함수
---

수를 늘리는 방법에는 
'''

def send_message(n):
    '''
n : 엘리스가 전송해야 할 암호 문자의 개수
bfs

기저조건 n=5
n이 
0=삭1
1=0
2=복붙2-----------------1+2^0
3=복붙붙3               1+2^0 *2
4=복붙복붙4-------------1+2^0 +(1+2^0)
5=복붙붙붙붙5           1+2^0 *4
6=복붙복붙붙5           (1+2^0)*3
7=복붙복붙붙붙삭7       ((1+2^0)*2)*2-1
8=복붙복붙붙붙6---------((1+2^0)*2)*2
9=복붙복붙붙붙붙삭8-----(1+2^0)*5-1
10=복붙복붙붙붙붙7------(1+2^0)*5
11=복붙복붙붙붙붙붙삭9--
12=복붙복붙붙붙붙붙8----
13=복붙복붙복붙붙삭삭삭10
14=복붙복붙복붙붙삭삭9
15=복붙복붙복붙붙삭8
16=복붙복붙복붙붙7

'''
from collections import deque
'''
n : 엘리스가 전송해야 할 암호 문자의 개수
bfs

기저조건 n=5
n이 
0=삭1
1=0
2=복붙2-----------------1+2^0
3=복붙붙3               1+2^0 *2
4=복붙복붙4-------------1+2^0 +(1+2^0)
5=복붙붙붙붙5           1+2^0 *4
6=복붙복붙붙5           (1+2^0)*3
7=복붙복붙붙붙삭7       ((1+2^0)*2)*2-1
8=복붙복붙붙붙6---------((1+2^0)*2)*2
9=복붙복붙붙붙붙삭8-----(1+2^0)*5-1
10=복붙복붙붙붙붙7------(1+2^0)*5
11=복붙복붙붙붙붙붙삭9--
12=복붙복붙붙붙붙붙8----
13=복붙복붙복붙붙삭삭삭10
14=복붙복붙복붙붙삭삭9
15=복붙복붙복붙붙삭8
16=복붙복붙복붙붙7

'''
'''
n : 엘리스가 전송해야 할 암호 문자의 개수
bfs
'''
from collections import deque
def send_message(n):
    check = [ [0 for _ in range(973)] for _ in range(973)]  #0라인은 실상 안씀?
    queue = deque()
    queue.append([1, 0, 0]) #화면문자수, 버퍼, 시간

    while queue: #완전히 빌때까지
        printNum, clipboard, time = queue.popleft() #변수로 저장
        
        #목표달성?
        if printNum == n: 
            return time

        #재방문?
        if check[printNum][clipboard]:
            continue #Yes
        else: #No 최초방문
            check[printNum][clipboard] = 1 #방문표시
            if printNum: #뭔가있으면                                          
                queue.append([printNum-1, clipboard, time+1])           #삭제경우
                queue.append([printNum, printNum, time+1])              #복사경우

            if clipboard: #뭔가있으면                                    
                queue.append([printNum+clipboard, clipboard, time+1])   #붙여넣기

def main():
    
    while True:
        n = int(input())
        
        result = send_message(n)
    
        print(result)

if __name__ == '__main__':
    main()


def main():
    '''
    테스트를 위한 코드입니다.
    '''
    
    n = int(input())
        
    result = send_message(n)
    
    print(result)

if __name__ == '__main__':
    main()
