'''
동적계획법(DP,dynamic programming) : """문제의 중복성(반복성 재귀와 다름)""" (하위문제의 결과가 상위문제해결의 인자인 경우)
큰문제를 함수의 반복/재귀로 표현하되,하위문제의 답을 저장하여 결과값을 '동적'으로 갱신하고, 갱신된 결과를 상위문제해결에 사용함
(+= 나 배열에 저장하는 방식등으로 재귀/반복중 갱신, 갱신-저장된 값은 중복연산하지 않음으로써 성능향상)

피보나치수열 : 일반 재귀인 경우 완전탐색 O(2^n), 동적계획법인 경우 저장된 값은 중복연산하지 않음으로 O(n) 
동적계획법 : bottumup(반복) topdown(재귀) 두가지 점화식 방식있음

동적계획법 프로그래밍 순서
1.구하고자하는 값 정의 (마지막 값이 나오는 로직을 재귀적으로 생각해보기)
2.부분문제로 표현하여 점화식 구하기 (규칙을 발견하는 왕도나 공식은 없다;;;)
3.bottumup(반복) topdown(재귀) 중 한가지로 코딩하기 : 기저+반복

분할정복법 vs 동적계획법, 모수가 큰 문제A는 모수가 작은 문제B~Z의 합인가?
1.문제의 중복성: 중복x vs 중복o
2.문제 나누는 법: 문제의 모수자체를 기저까지 나눔(각연산자체는 독립적) vs 반복/재귀로 기저부터 값을 구함(연산이 종속/중복적)
-->활용: 퀵정렬 vs 피보나치
-->공통점: 둘다 재귀의 형태로 표현될 수 있다는 점에서 같다(재귀문제는 분할정복법에 의한 것일수도 동적계획법에 의한 것일수도 있다.)



2 x n 의 상자를 2 x 1 의 블럭으로 채우는 경우의 수를 구하는 프로그램을 작성하세요. 단, 그 경우의 수가 매우 커질 수 있기 때문에, 경우의 수를 1,000,000,007으로 나눈 나머지를 출력합니다.
4
5
'''

def fillBox(n) : #buttomup 기저부터 시작해서 반복 채워나가기
    memo = [1,1]
    for i in range(2,n+1):
        memo.append( (memo[i-1]+memo[i-2]) %1000000007) #memo[n]구하려고 memo[2]부터 다 연산, 직전두개로 다음 것 계산

    return memo[n]

#재귀시 초기화되서 memo를 내부변수로 초기화못해주고, 대신 인자로 받아줌
def fillBox_topdown(n) : #탑(n)부터 아래로 재귀해서 기저반환
    # if n == 0 or n == 1:
    #     return 1
    memo=[1,1]
    if not n in memo:
        memo[n] = ( fillBox_topdown(n-1) + fillBox_topdown(n-2) )%1000000007 #memo[n] = memo[n-1] + memo[n-2] 이용해서 기저까지 전부 재귀
    return memo[n]


#main.py
def main():
    '''
    아래 부분은 수정하지 마세요.
    '''

    n = int(input())

    print(fillBox(n))

if __name__ == "__main__":
    main()
