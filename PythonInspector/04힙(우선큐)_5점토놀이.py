'''
점토 놀이
엘리스씨는 가장 적은 힘을 사용하여 주어진 모든 점토를 합치고 싶어졌습니다. 
엘리스씨를 도와 n개의 점토를 하나의 덩이로 합치기 위해 필요한 힘의 크기의 합의 최솟값을 구하는 프로그램을 작성하세요.
만약 무게가 a인 점토와 무게가 b인 점토를 한 덩이가 되도록 합치기 위해서는 a+b의 힘을 들여야 합니다.

입력
첫 번째 줄에 점토의 개수 n이 입력됩니다.(1≤n≤100,000)
두 번째 줄에 각 점토의 무게를 의미하는 n개의 정수가 공백으로 구분되어 입력됩니다.(1≤점토의 무게≤1,000,000)

출력
모든 점토를 한 덩이로 합치기 위해 필요한 힘의 크기의 합의 최솟값을 출력합니다.
4
1 5 7 3

29
'''
import heapq
def getMinForce(weights) : #점토들의 무게를 인자로함
    '''
    n개의 점토를 하나로 합치기 위해 필요한 힘의 합의 최솟값을 반환하는 함수를 작성하세요.
    ==>한번 더 해진 수가 이후 연산에 인자로 사용되면서 중복으로 더해지는 효과가 있음으로
    ==>두개씩 반드시 더해야만 한다면 가장 작은수끼리 먼저 더해야 중복 가산을 최소화할 수 있음  
    '''
##세팅
    pq = []
    for w in weights:
        heapq.heappush(pq,w) #힙푸쉬임으로 모든 w는 최저힙으로 정렬됨
    result = 0

##계산
    while len(pq) > 1: #pq에서 점토가 하나남을때까지
        
    #힙::팝: 최우선순위(루트)반환하고 삭제 ==>가장 작은수 두개 연달아 꺼내기(그와중에 단계별정렬)
        x = heapq.heappop(pq) 
        y = heapq.heappop(pq)

        temp = x + y
        result += temp #더한 수 저장

        heapq.heappush(pq,temp) #더한 수 최저힙에 푸쉬(또 정렬)

    return result

def main():
    '''
    테스트를 위한 코드입니다.
    '''

    n = int(input())

    line = [int(x) for x in input().split()]

    print (getMinForce(line))

if __name__ == '__main__':
    main()
