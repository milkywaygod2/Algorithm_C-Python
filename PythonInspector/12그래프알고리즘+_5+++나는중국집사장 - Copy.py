'''
배달을 위한 길 횡단 횟수를 반환한다.

나-는 중국집 사장
나-는 중국집 사장이다. 그리고 배달도 내-가 한다. 근데 지금 주문이 너-무 많이 밀려 있다. 
더군다나 주문 마-다-마-다 풀코스요리를 주문해서 배달해주고 다시 가게에 들러 새로 음식을 가져가서 배달을 또- 해야 한다. 
심지어 우리 동네에는 있는 길도 있고 없는 길도 있고 하기 때문에 길을 잘 찾아보고 가야 빠르게 배달이 가능하다. 
나-는 전.지.적 작가 시점이라서 어느 집에서 다른 집으로의 길이 있는지 없는지 알 수 있다. 
빠른 길로만 다니면서 모-든 집에 배달을 완료 하려면 몇 번이나 그 길들을 왔다 갔다 해야할까?

graph
나-의 중국집은 1에 존재한다. 따라서 1에서부터 다른 집까지의 거리를 계산하여 모두 더 해주면 된다. 
물론 길이 없는 집은 배달가지 않는다. 따라서 그런 집은 지도에 그려주지도 않을 것이다. 우리 동네 지도가 예시와 같다면,
1 -> 2 -> 1 : 길 2번
1 -> 3 -> 1 : 길 2번
1 -> 3 -> 4 -> 3 -> 1 : 길 4번
1 -> 5 -> 1 : 길 2번
이기 때문에 2 + 2 + 4 + 2 = 10 개의 길을 다녀야 배달이 완료된다.

입력
입력의 첫 줄에는 집의 수 N 과 집과 집 사이에 길이 존재하는지 알려주는 순서쌍의 개수 R 이 입력된다. 
그리고 다음 R 줄 동안 집과 집 사이에 길의 존재로 순서쌍이 입력된다. 순서쌍은 1 부터 N 이하의 수로만 이루어져 있다. 
(2≤N≤100,2≤R≤N(N+1)/2−1)

출력
각 상황에 대한 배달을 위한 길 횡단 횟수를 쓴다.

입력 예시
5 5
1 2
1 3
1 5
3 4
4 5

출력 예시
10
'''
def pathCount(graph) :

    ret = 0

    return ret

#main.py
def main() :
    '''
    이 부분은 수정하지 마세요.
    '''
    line = input().split()
    N = int(line[0])
    R = int(line[1])
    graph = [[0 for i in range(N)] for j in range(N)]
    for j in range(R) :
        line = input().split()
        graph[int(line[0])-1][int(line[1])-1] = 1
        graph[int(line[1])-1][int(line[0])-1] = 1
    print(pathCount(graph))

if __name__ == "__main__":
    main()
